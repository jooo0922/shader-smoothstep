#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

// Plot a line on Y using a value between 0.0-1.0
float plot(vec2 st, float pct) {
  /*
    plot 이라는 사용자 정의 함수의 두 번째 인자인 float pct는 
    호출될 때, float y값을 전달받고, float y = st.x 이므로,
    결국 두 번째 인자는 st.x 값이 전달된다고 보면 됨. 
    (즉, 이 함수 내에서 pct = 각 픽셀의 정규화된 x좌표값)

    그러면, 아래 main 함수 안에서도 보듯이
    화면에서 '하나의 열' 안에 존재하는 픽셀들은 모두 동일한 pct, 즉 st.x 값을 가지고 있지?

    따라서, 첫 번째 smootstep() 함수는,
    각 픽셀의 보간된 y좌표값(st.y)이 (st.x - 0.02) 보다 작으면 0을 리턴하고,
    st.x 보다 크면 1을 리턴하고, (st.x - 0.02)와 st.x 사이에서는 0 ~ 1 사이를 보간해주는 값을 리턴함.
    즉, 해당 픽셀의 y좌표값이 (x좌표값 - 0.02)보다 작으면 0을 리턴하고, 
    x좌표값보다 크면 1을 리턴하고,
    (x좌표값 - 0.02) ~ x좌표값 사이라면 0 ~ 1 사이를 보간해주는 값을 리턴한다는 것!
    (first_smoothstep.png 참고)

    두 번째 smoothstep() 함수도 마찬가지 원리!
    각 픽셀의 y좌표값이 x좌표값보다 작으면 0을 리턴, 
    (x좌표값 + 0.02)보다 크면 1을 리턴,
    x좌표값 ~ (x좌표값 + 0.02) 사이라면 0 ~ 1 사이를 보간해주는 값을 리턴함.
    (second_smoothstep.png 참고)

    두 번의 smoothstep 함수 호출의 리턴값을 기준으로
    모든 픽셀들을 4개의 구간으로 나눌 수 있게 됨. (구간_나누기.png 참고)

    그래서, 각 픽셀들의 구간별 리턴값을 계산할 수 있고, (구간별_리턴값_계산.png 참고)

    구간별_리턴값_분포.png 사진을 참고하면 초록선 방향을 기준으로
    4개의 구간별 각 픽셀들에 대해 plot() 함수가 리턴해주는 값을 정리해줄 수 있음.
  */

  // 원래 그냥 0.02만 더했던 예제를, 다양한 span값으로 변경해보면서 실험하려고 span이라는 변수에 따로 담아서 사용함.
  // 그래서 span값이 늘어나면 늘어날수록, 구간_나누기.png에서 2, 3에 해당하는 구간이 점점 늘어나서
  // green 컬러가 보간되는 영역이 더 넓어지게 되는것임.
  float span = 0.02;

  return smoothstep(pct - span, pct, st.y) - smoothstep(pct, pct + span, st.y);
}

void main() {
  // 지난 예제에서도 봤듯이 각 픽셀 좌표값을 화면 전체 해상도로 각각 나눈 vec2 값이 계산될거임.
  // 이 코드가 하는 역할은 결국, 해상도가 500 * 500 이라면,
  // 0 ~ 500 사이의 x, y 좌표값을, 0 ~ 1 사이의 좌표값으로 Mapping 시키는, 즉, normalize 하는 효과와 동일함!
  // gl_FragCoord 에 저장된 각 픽셀의 좌표값을 0 ~ 1 사이의 값으로 normalize 한다고 생각하면 됨!
  vec2 st = gl_FragCoord.xy / u_resolution;

  float y = st.x; // normalize된 각 픽셀의 x좌표값을 float y에 넣어주고,

  // 이게 첫번째로 중요한 부분 같은데,
  // vec3(y)로 넣어줬다는 것은, (y, y, y) 라는 vec3 데이터를 만들어서 vec3 color에 넣어준거라고 보면 됨.
  // 즉, 각 픽셀의 정규화된 x좌표값을 r, g, b 값으로 사용할 vec3 데이터로 만든거임.
  // 이 때, 아주 중요한 포인트가 뭐냐면, r, g, b값이 똑같은 색상은 '무채색 계열'로만 찍힌다는 거임.
  // vec3 color = vec3(0.5, 0.5, 0.5); 이거로 색상 찍어보면 중간값인 회색이 나오는 것처럼!
  // 그래서 캔버스에 찍히는 그라데이션이 무채색으로만 나왔던 거임!
  vec3 color = vec3(y);

  // Plot a line (아래 세 줄은 초록색 그래프를 그려주는 코드)
  float pct = plot(st, y); // plot() 함수에서의 각 픽셀들의 구간별 리턴값이 pct 값에 들어가게 됨.
  color = (1.0 - pct) * color +
    pct * vec3(0.0, 1.0, 0.0);
    /*
      이 color 변수에 추가적인 계산을 해주는 코드를 설명하자면,
      더하기 연산자를 기준으로 두 곱셈식을 나눌 수 있지 일단.

      1. 첫번째 곱셈식
      (1.0 - pct) * color 얘는 뭐냐면,
      원래 초록색 컬러를 찍지 않았더라면 해당 픽셀자리에 찍혔을 '배경색'을 의미함.
      이 때, pct가 0으로 계산된 픽셀은, 원래의 배경색인 vec3 color에 (1 - 0) 즉, 1을 곱하니까,
      배경색이 그대로 살게 되고,
      pct가 1로 계산된 픽셀은, 원래의 배경색인 vec3 color에 (1 - 1) 즉, 0을 곱하니까,
      배경색이 0에 의해 곱해져서 다 죽어버리게 되는 것.

      2. 두번째 곱셈식
      두번째 곱셈식은 첫번째 곱셈식의 완전 반대라고 보면 됨.
      한마디로, pct값에 의해 그래프의 '초록색'을 살리냐 죽이냐, 살릴거면 얼마나 살리냐 그거지.
      pct가 1이면 초록색이 그대로 살아나고(대신 첫번째 곱셈식에서 배경색은 죽음)
      pct가 0이면 초록색이 죽어버림(대신 첫번째 곱셈식에서 배경색이 그대로 살게 됨.)

      -> 결론적으로 말하면, 저 pct값에 따라서,
      '배경색'은 얼만큼의 비율로 살릴 것인가(첫번째 곱셈식)와
      '초록색'은 얼만큼의 비율로 살릴 것인가(두번째 곱셈식)을 결정하여
      color값을 다시 계산하게 되는거임.

      즉, 배경색과 초록색을 '섞는 비율'을 계산해서 
      섞여진 색상값을 다시 color에 넣어주는 것이지!
      pct(또는 1-pct)를 각 vec3 색상값에 상수배한 뒤, 
      각 vec3 색상값 성분끼리 더해주는 벡터 연산을 해서 색상값을 섞는 것임.

      -> 이게 바로 shader에서는 mix() 라는 내장함수를 그대로 구현된 거라고 보면 됨.
      다만 저자가 아직 mix() 함수에 대해서 설명하기가 애매하다고 판단해서
      직접 짠 코드를 활용한 것 같다고 함.   
    */

  // 각 픽셀의 색상값을 해당 픽셀의 정규화된 x좌표값으로 r, g, b를 모두 구성하도록 했음.
  // 즉, x좌표값이 동일한 픽셀들끼리는 (즉, 같은 '열'에 해당하는 픽셀들은) 색상이 동일할거임.
  // 이 때, 정규화된 x좌표값이 0인 지점은 r, g, b가 (0, 0, 0) 이니 black이 찍힐 것이고,
  // 정규화된 x좌표값이 1인 지점은 r, g, b가 (1, 1, 1) 인 white로 찍힐 것임.
  // 따라서 왼쪽에서 오른쪽으로 갈수록 정규화된 x좌표값이 1에 가까워지므로, 
  // 왼쪽일수록 검은색, 오른쪽으로 갈 수록 흰 색을 찍어주는 그라데이션이 완성되는 것.
  gl_FragColor = vec4(color, 1.0);
}

/*
  step(float edge, float x)  

  smoothstep() 내장함수를 설명하기 전에 이 내장함수를 먼저 알아야 함.
  
  예를 들어, 
  y = step(0.5, x); 이렇게 코딩을 하면,
  x로 넣어준 값이 0.5보다 작으면 0, 0.5보다 크면 1을 리턴해주는 거라고 보면 됨.


  smoothstep(float edge0, float edge1, float x) 

  smoothstep()은 step()과 비슷하기는 하지만,
  step()에서는 결과값 y를 그리는 그래프를 보면 (https://thebookofshaders.com/glossary/?search=step)
  0과 1 사이의 분절이 급격하게 이뤄졌지만,

  smoothstep()은 결과값 y를 그리는 그래프를 보면 (https://thebookofshaders.com/glossary/?search=smoothstep)
  0과 1 사이에 보간이 일어나고 있음.

  그 보간이 어떻게 일어나느냐?
  y = smoothstep(0.0, 1.0, x); 만약 이렇게 코딩을 하면,
  x의 값이 0.0 ~ 1.0 사이인 구간의 그래프에서 보간이 일어나도록 함. 

  즉, 저 코드는 
  -x의 값이 0 미만이면 리턴하는 값이 0
  -x의 값이 1보다 크면 리턴하는 값이 1
  -x의 값이 0과 1 사이에서는 s자 곡선으로 서서히 보간작업이 일어나면서 서서히 커지는 값으로 리턴함.
  -> 이게 바로 smoothstep() 함수의 역할.
*/